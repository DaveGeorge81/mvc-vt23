{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
<h1>Redovisningstexter<hr></h1>
<div class="two-col-layout">
    <aside class="aside">
        <h4>Innehåll:</h4>
    <ul>
        <li><a href="#kmom01">kmom01</a></li>
        <li><a href="#kmom02">kmom02</a></li>
        <li><a href="#kmom03">kmom03</a></li>
        <li><a href="#kmom04">kmom04</a></li>
        <li><a href="#kmom05">kmom05</a></li>
        <li><a href="#kmom06">kmom06</a></li>
        <li><a href="#kmom10">kmom10</a></li>
    </ul>
    </aside>
    <main class="main">
        <section><h2 id="kmom01">kmom01</h2>
        <p>Första veckan i kursen Objektorienterade webbteknoligier, eller som den även förkortas till; mvc. Mina förkunskaper gällande objektoriernterad programmering
        är relativt begränsade. Jag läste oopython-kursen tidigare i vår, och det var i början ganska krångligt att greppa. Men känner ändå att jag fick rätsida på
        det under kursens gång. Det är ett litet annat tankesätt när man jobbar obejktorienterat, men tror ändå att jag har kommit att föredra det.</p>

        <p>I PHP räcker det inte med att bara skapa klasser, man måste även skapa ett så kallat namespace. Man kan se namespace som en mapp eller katalog vari koden körs. Detta 
        för att klassnamnen inte ska krocka med andra klasser. Detta är något jag inte kände igen från oopython-kursen, men verkar hittills inte krångligare än att man anger sitt
        namespace i början i sina controller-filer. I detta första kursmoment uppelver jag inte att vi mer än skrapat på ytan då de klasser vi skapat i princip enbart består av routes
        till de olika sidorna vi skapat. Men antar att vi kommer gå djupare med att skapa objekt i våra klasser i framtida kursmoment.</p>

        <p>Den struktur som vi byggt upp med hjälp av Symfony påminner en del om express som vi använde i databaskursen, men jag kan även se vissa likheter med flask som vi använde i 
        oopython. Det är alltid lite rörigt i början när man inte är helt van vid kodstrukturen, men det ska nog inte vara några problem att använda detta. En del av kraven var dock lite
        kluriga att få till. Var tvungen att gå tillbaka och titta på en och två gånger hur jag gjort i webtec-kursen i höstas. Man glömmer ganska snabbt när man inte använder något, och 
        PHP har jag knappt använt sedan dess. Men samtidigt är inte startsträckan särskilt lång när väl börjar tänka tillbaka på vad man lärt sig tidigare. </p>

        <p>Artikeln "PHP The Right Way" var ganska överväldigande och handen på hjärtat läste jag inte igenom den rad för rad. Något jag fann intressant var varför vi använder templates,
        det är inte första gången vi arbetar med detta och har väl egentligen aldrig reflekterat över varför vi faktiskt gör det. Jag fick här en ganska bra förklaring att det underlättar
        att separera koden och det som presenteras på webbsidan då det blir mer överskådlig, inte minst om man jobbar i team och en sitter med koden på serversidan och en annan med designen
        på klientsidan. Jag fick även lite mer kött på benen gällande det här med namespace, som jag bekrev ovan.</p>

        <p>Veckans TIL har precis som alltid vid kursuppstart varit en hel del. Men det jag nog känner mest för är att jag ökat min förståelse för GIT. Vi använde det i design-kursen i höstas,
        men jag kände mig väldigt osäker varenda vecka på hur jag skulle göra, och den skrivna guiden var ganska rörig att leta sig igenom vecka efter vecka. Mikales git-guide på youtube var
        väldigt mycket enklare att ta till sig och jag känner mig betydligt säkrare på git efter att ha sett den.</p>


        <hr>
        <h2 id="kmom02">kmom02</h2>
        <p>Den här veckan har vi jobbat vidare med klasser i php. Vi har skapat en kortlek med lite olika funktioner. Jag tyckte egentligen inte det var så svårt att greppa,
        men det tog väldigt lång tid att komma igång och jag gjorde det nog initialt betydligt svårare än vad som hade behövts.</p>

        <p>Arv, interface, composition och trait var mestadels nytt för mig. Vi har pratat om arv i oopython och composition så det kände jag mig ändå lite bekant med. Arv är 
        när man skapar en klass som tar allt som klassen den ärver av, men kan lägga till vissa saker utan att det påverkar själva huvudklassen. I mitt fall gjorde jag ett arv
        på Card-klassen när jag skapade CardGraphic. I CardGraphic la jag till en array där kortets värde kan kopplas till en specifik bild. Composition är som ett beroende. Att den
        ena klassen inte kan existera utan den andra. Här valde jag att låta både DeckOfCards och CardHand vara sådana konstruktioner. En kortlek kan inte finnas om det inte finns några kort
        och en hand med kort kan inte heller den finnas om det inte finns några kort. Interface var nytt för mig och jag kom inte riktigt på hur jag skulle implementera det i mina klasser. Men
        man kan i alla fall säga att ett interface är en typ samling av metoder en klass ska innehålla, men inte hur de ska implementeras. Som jag förstod det så innebär detta t ex att jag inte 
        hade behövt hårdkoda CardGraphic i min DeckOfCards, utan att man kan göra det mer flexibelt med interface. Som jag skrev fick jag aldrig ritkigt ihop koden med interface, så jag fick nöja
        mig med att hårdkoda denna gång. Trait är något som gör att en klass kan återanväda kod från ett trait utan att behöva implemetera det i själva metoden. Detta används ofta i språk där
        klasser inte kan ärva från mer än en klass. Även detta var något jag inte riktigt fick koll på exakt hur jag skulle göra, utan tänker att jag kanske får återkomma till det i senare kursmoment.</p>

        <p>Som jag skrev i början av texten hade jag väldigt svårt att komma igång med detta. Det var svårt att veta exakt var jag skulle börja när det var såpass öppna instruktioner. Jag började i alla fall
        med att skapa klassen Card, och därefter CardGraphic, CardHand och DeckOfCards. Det tog mig ganska lång tid att komma underfund med hur jag skulle göra för att skapa kortleken så att alla kort fanns med.
        När den väl var skapad kom nästa stora problem. Att ta bort kort från leken. Initialt gjorde jag det rätt mycket mer komplicerat än vad det behövde vara. Jag hade numrerat alla kort, och tänkt att jag då
        slumpar fram ett nummer mellan 0-51 och tar bort kortet med det numret. För att inte samma kort skulle försöka tas bort mer än en gång la jag varje draget nummer i en array som "random" sen exkluderade.
        Jag märkte dock att detta ibland genererade ett null-värde. Efter åtskilliga timmars felsökning utan framgång kom jag på att det var mycket enklare att bara blanda leken och ta bort de översta korten. Denna
        metod gav inte några slumpässiga null-värden som tur var så när jag väl ändrade detta så löste jag de andra uppgifterna. API-delen var inte så svår, men jag fick klura lite på hur jag skulle göra med
        sessionen. Först hade jag tänkt att kortleken till API-delen inte skulle innhålla CardGraphic utan vanliga Card. Problemet var att jag ville behålla sessionen oavsett om man tittade i api-delen eller 
        på card-sidan. För att lösa detta fick jag skapa nya getAsString-metoder som jag kallade getAsStringJson för att rätt data skulle visas berode på var man kollar.</p>

        <p>Överlag är jag ganska nöjd med slutresultatet av kursmomentet, men jag är lite missnöjd över att det tog mig så lång tid att färdigställa. Jag hoppas på bättre flyt i kmom03. Förbättringspotentialen
        ser jag främst i att jag kanske kunde implementerat ett interface så att jag inte behövt hårdkoda i DeckOfCards och kanske något trait då många metoder är samma i de olika klasserna. Det var som sagt ganska 
        klurig att göra en sån här fri uppgift, men jag känner ändå att jag har lärt mig mycket och kan tänka mig att detta är ett bra sätt att träna på hur det kan vara i en framtida yrkesroll.</p>

        <p>Veckans TIL blir det fortsatta arbetet med symfony och då framför allt hur man kan jobba med sesisonen, men även lite mer förståelse för hur POST och GET fungerar. </p>

        
        <hr>
        <h2 id="kmom03">kmom03</h2>
        <p>Denna vecka har vi fått utveckla ett eget kortspel. Som en del i detta skulle vi göra både ett flödesschema och skriva psuedokod. Flödesschemat var relativt enkelt att göra då jag tyckte det
        kändes ganska logiskt hur man skulle rita upp det. Eftersom jag gjorde det innan jag började skriva koden blev det inte exakt som i slutända men det är väl lite det som är tanken, att man har ett skal att
        utgå från som man senare kan finslipa ju mer man jobbar med det. Psuedokoden tyckte jag var lite klurigare. Det var inte helt lätt att bestämma vad jag skulle fokusera på, i ett par fall kom jag inte på hur 
        jag skulle få fram det jag skulle koda i psuedokoden, t ex om spelaren vill stanna eller dra ett nytt kort. Jag valde därför enbart att skriva psuedokod för banken spelrunda. Det kändes mer logisk då jag vet
        när banken stannar eller drar ett nytt kort. Det finns lite olika sätt att skriva psuedokod på, men jag skriva den som kommentarer man sedan kan ta in i källfilen när man ska koda. Det tycker jag känns som ett
        anävndbart sätt att använda psuedokoden på och något jag förmodligen kommer använda mig av i framtiden. Jag har väl inte riktigt kommit in i problemlösningstankesättet riktigt ännu utan oftast sätter jag igång och
        börjar koda direkt. Det blir då ofta att man gör lite här och lite där och sen i slutändan måste ändra en massa, så jag kan absolut se fördelar med att jobba så här.</p>

        <p>Jag valde att göra kortspelet 21. Det var inte så svårt att komma igång och låta spelaren dra kort. Den koden hade jag ju redan från kmom02. Det jag tyckte var svårast var faktiskt hur jag skulle få spelet att se
        Ess som både 1 och 14. Jag tänkte som vanligt i mer avancerade banor än jag behövde, men kom tillslut fram till att det enklaste vore att spela essen som 14 så länge inte poängen överstiger 21. Efter lite klurande kom
        jag fram till att detta enklast löstes med en while-loop. Jag är inte jättevan vid att arbeta med while-loopar då jag tenderar att luta mig mot if-satser och for-loopar. Men i detta fallet var det smidigare med en while-loop.
        Att sen låta datorn spela en runda var inte heller det särskilt svårt. Även här insåg jag att en while-loop också kunde vara på sin plats. Så länge datorns poäng understiger 17 dras ett nytt kort. Jag hade först tänkt
        att jag skulle göra samtliga extra-krav, för jag tyckte de verkade lagom utmanande. Dessvärre drog jag på mig kraftig förklylning vilket gjorde att jag inte hann med alla. Jag lyckades dock lägga in att man kan satsa pengar
        och att man spelar tills dess att antingen banken eller spelaren är bankrutt. Jag främst att bara jobba med de klasser vi skapade i kmom02. Men när jag skulle implementera betting-funktionen tänkte jag att det vore smidigt
        att skapa en Player-klass också. Det blev en ganska liten klass, men hade kunnat utvecklas mer om man gör spelet mer avancerat. Det jag tyckte var absolut svårast var att försöka hålla controller-filerna så små som möjligt.
        Tycker inte att jag skriver mycket kod där egentligen men en while-loop här och en eller två if-satser där så känns de inte så magra längre. Dock så består koden i controller-filerna mest av kallandet på metoder så det kanske
        inte är så farligt ändå? Men det är nog den främsta förbättringspotentialen jag ser med mitt arbete. Designen är jag relativt nöjd med. Hade kunnat göra knapparna lite snyggare t ex, men css-styling tar ofta lång tid och tyvärr
        oftast det som hamnar längst ner på prioriteringslistan.</p>

        <p>Jag känner att jag börjar få lite bättre grepp om symfony nu. Twig, controller och class-filerna är inga problem. Men ibland glömmer man lite i vilka filer man gör vad. Jag satt förgäves och letade efter var jag implementerat
        flash-meddelanden nånstans för att se så jag inte gjort något fel då min css-kod inte ville fungera. Var säker på att de skulle ligga i antingen app.js eller index.html eller någon sådan fil. Men tillslut visade det sig att det var
        en vanlig twig-fil det låg i. Förmodligen rörde jag ihop det med toast-meddelande från webapp-kursen. Jag känner också att jag tycker POST och GET metoderna börjar falla mer och mer på plats nu. När jag skapade post-formuläret för 
        att kunna satsa pengar behövde jag inte ens kolla på min gamla kod, det föll sig helt naturligt hur jag skulle göra, så det känns bra.</p>

        <p>Veckans TIL har kanske inte så mycket med just symfony att göra, det är mer själva problemlösningstankesättet jag känner jag fått förståelse för. Men också att jag lärt mig använda while-loopar på ett användbart sätt.</p>

        <hr>
        <h2 id="kmom04">kmom04</h2>
        <p>Den här veckan har fokus legat på enhetstestning. Det kändes inte som att detta var så jättenytt då vi sysslat en del med detta i oopython-kursen. Det var ganska likt sätt man skriver testerna på så det kändes ganska bekant.
        Phpunit tycker jag var lite tydligare när ett test går fel än när vi gjorde enhetstester i pyhton. Det är ett ganska smidigt sätt att jobba med sin kod, men jag hade lite beskymmer med att få det att fungera i min report-mapp. När jag gjorde
        som i övningen fast i report-mappen skrevs en hel del av mina filer över, vilket gjorde att ingenting ville fungera. Fick tillslut ladda ner hela report-mappen från stundentservern och börja om igen och installera om allt jag hade i tools-mappen.
        Lite irrerande, men när allt var på plats igen fungerade det som det skulle.</p>

        <p>Jag tycker nog att jag lyckades ganska bra med min kodtäckning. Fick 98,65% täckning, vilket jag är nöjd med. Att jag inte fick 100% var på grund av en metod med en if-sats ifall kortleken var tom. Jag hade visserligen kunnat göra en loop som
        tömt kortleken innan jag testade metoden för att få fram båda resultaten, men det kändes som mycket jobb för en såpass liten del att jag lät den vara. En annan sak jag klurade på var hur jag skulle testa att kortleken blandades. Jag kom inte på någon
        vattentät lösning, men la in att leken skulle blandas i samma test som sorterar leken. Blanda först och sedan sortera. Tycker nog överlag att min kod var väl inom marginalen för testbar. Behövde inte skriva om mycket av koden alls. Det var bara en metod
        jag valde att ändra på. I metoden drawSingle hade jag tidigare valt att börja med att blanda leken innan kortet drogs. Det fyllde en funktion i kmom02 där man skulle dra ett kort från leken. Här valde jag istället att lyfta ut blandandet av leken utanför
        metoden och la det istället i controllern. Det gör att det blir lite mer kod i controllern, men koden blir lättare att testa. När jag gjorde detta insåg jag att jag egentligen inte behövde två olika metoder för att dra ett kort (gjorde en ny till tjugoett-spelet
        där leken inte blandas varje gång man drar kort). Jag hade kunnat effektivisera koden och återanvända en av dessa två metoder nu när jag ändrat den första, men då klockan är mycket och jag gärna vill lämna in innan jag går och lägger mig får det vara så för den
        här gången. </p>

        <p>Om snygg och ren kod gör koden mer testbar är någon man kan fundera över. På ett sätt är kan man anta att kod som är snygg och ren bör vara skriven på ett sätt som gör den lättare att testa, att det inte finns massa beroenden som kan ställa till det. Men det är
        egentligen ingen garanti att kod som inte är snygg och ren skulle vara mindre testbar. Det behöver inte finnas beroenden eller en uppbyggnad som sätter käppar i hjulet bara för att koden är "kladdig". Dock får man nog ändå anta att den som lägger ner tid på att skriva
        snygg och ren kod även tänker på att göra den lätt att testa.</p>

        <p>Veckans TIL blir nog en lite mer ökad förståelse för vad enhetstestning innebär, och att man ska försöka testa rätt saker. 100% kodtäckning behöver inte vara en garanti att man testar allt rätt. Att testkoden ibland kan bli större än själva koden man testar är också
        något jag lärde mig.</p>

        <hr>
        <h2 id="kmom05">kmom05</h2>
        <p>Den här veckan har handlat om ORM (Object relational mapping), och att vi kopplar en liten databas till vår sida. Övningen för hur man kom igång med Doctrine i Symfony var bra då den gick igenom i princip allt man behövde kunna för att sedan klara av uppgiften för kursmomentet.
        Det var relativt lätt att komma installera på ett helt färskt symfony-prokjekt. Men när jag istället skulle installera det i report-mappen stötte jag på lite problem. Framför allt var det maker-bundle som inte ville installeras. Composer hävdade att det inte fanns något att installera,
        medan när jag försökte använda maker för att skapa en entity så protesterades det och påstods att jag inte hade maker installerat. Jag fick in och städa lite i min composer.json innan jag tillslut fick allt på plats. Det kan eventuellt ha att göra med det strul jag hade förra vecka när
        jag fick återskapa hela report-mappen. Men nu ska förhoppningsvis allt fungera även i fortsättningen. Mikaels genomgång av övningen var även den väldigt bra då det ger lite inblick än att bara läsa sig till funktionaliteten.</p>

        <p>När jag byggde upp själva biblioteks-applikationen tänkte jag att man ska kunna komma åt allting oavsett på vilken sida man befinner sig. Jag valde därför att skapa en side-bar med knappar där man kan växla flik. Jag tänkte först även ha att man skulle kunna ta bort och redigera böcker
        från side-baren. Men ansåg att det var enklare att lägga de valen i listan där man hittar alla böcker. Men för användarvänlighetens skull så la jag även till dessa funktioner om man väljer att gå in på en specifik bok. En annan tanke jag hade var att man skulle kunna gå mellan böckerna på
        varje enskild boks sida med hjälp av pilar fram och tillbaka. Det ställde dock till det lite då id-numren följs numeriskt när man tagit bort en bok. Det hade ju självklart gått att lösa på något sätt, men då jag just nu inte kommer ihåg hur och det är relativt begränsat med tid låter jag det
        istället vara som en idé för framtiden.</p>

        <p>CRUD är ju i sig ingen nyhet, men att jobba med det så här kändes lite annorlunda än vad jag vant mig vid hittills. Jag känner mig ganska bekväm med SQL-kod så det kändes lite ovant. Men det gick ganska snabbt att anpassa sig och även om jag inte alltid var helt säker på vad varje sak
        innebar så var helheten relativt enkel att förstå. Nu var det ju iofs inga avancerade anrop vi skulle göra, det var väl främst att kunna hitta en bok med hjälp av ISBN, men det fanns ju som tur var en exempel-metod man kunde utgå från som grund. Det är alltid spännande att lära sig att jobba
        på olika sätt, men jag känner nog ändå att jag hellre jobba med databaser med hjälp av mySQL eller mariadb på det sätt vi gjorde i databaskursen. Känner man sig osäker på SQL-biten är däremot ORM ett bra sätt att jobba på och jag kan absolut se potentialen i det då man kan arbeta mer objektorienterat 
        på detta sätt. Det är fullt möjligt att mina preferenser kan komma att luta mot ORM i framtiden om jag arbetar med det mer, då jag trots allt föredrar objektorienterad programmering. Om man jämför det med sättet vi jobbar mot ett API i webapp-kursen får jag nog säga att det är relativt likvärdigt.
        Där hämtar man all data från json, vilket jag egentligen nog tycker verkar krångligare. Men förmodligen handlar det ju även här om att jag är mer van vid det sättet att arbeta.</p>

        <p>Veckans TIL förutom vad ORM är så får det bli hur man använder doctrines manager för att skriva till och läsa från databasen.</p>

        <hr>
        <h2 id="kmom06">kmom06</h2>
        <p>Denna vecka har vi jobbat mer med att testa webbplatsen och hur väl man använder sig av clean code. Ett av verktygen vi använde av Phpmetrics. Där får man en god överblick över hur "clean" ens kod är. Vi har ju tidigare använt verktyg som kontrollerar hur väl koden är skriven, men Phpmetrics
        tar även med andra faktorer som t ex komplexibilitet och maintainability index (förmåga att kunna underhålla koden), men det går även att länka det till det resultat phpstan genererar så att man kan se hur mycket av ens kod man testar. Jag tyckte det var ett bra verktyg då det var lättöverskådligt
        med tydliga flikar om vad som är vad. Det jag främst uppskattade var mätningen för komplexibilitet, det blev väldigt tydligt med de olikfärgade cirklarna. När jag såg dessa blev det väldigt tydligt att den kod jag skrivit stundtals är ganska komplex, och fick mig att fundera på hur jag kanske kunde
        göra annorlunda.</p>

        <p>Det andra verktyget vi anväde var Scrutinizer. Det fungerar ihop med det repo man laddar upp på GitHub och kör clean code-testerna automatiskt så fort det görs en ny push till repot. Jag hade rätt mycket bekymmer med att få Scrutinizer att fungera initialt. Det blev ett antal felmeddelanden innan
        allt fungerade som det skulle. Scrutinizer blir också det väldigt tydligt med sina bagdes som visar hur väl koden är skriven enligt deras parametrar, hur stor procent kodtäckning man har samt om repot passerade build-testet. Mitt första godkända test (när allting fungerade) gav mig ett värde på 9.93
        och en kodtäckning på 16%. Det fanns ett par issues där merparten av dem var väldigt enkla att korrigera. 3st fick jag dock lämna kvar då jag förmodligen inte skulle kunna lösa dem. Scrutinizer med sina bagdes gör att resultatet blir om möjligt ännu tydligare än i Phpmetrics. Som vän av siffror ger
        ett slutvärde en betryggade känsla, man ser direkt om ens repo är okej eller om det finns förbättringspotential. I mitt fall handlade det ju främst om kodtäckningen, men det visade sig svårare än jag trott att utföra ytterligare tester. När jag var klar med mina förbättringar hade jag dock höjt värdet
        till 9.95 och kodtäckningen till 18%. På det hela taget gillar jag Scrutinizer och jag uppskattar att det uppdateras automatiskt.</p>

        Att ha god kodkvalitet kan ses lite som en kvalitetsstämpel, det visar att koden är skriven på ett sätt som gör den lättöverskådlig, det finns inga stora kända buggar och det bör med andra ord vara hyfsat enkelt för en utomstående att förstå koden. Att visa detta med hjälp av badges är ett enkelt sätt
        att få en generell uppfattning av koden. Dock kan den bli lite missvisande som t ex i mitt fall där kodtäckningen är alamerande låg trots att det främst handlar om controllerclasser som inte är testade. Likaså kan ibland ett högt resultat inte vara en garanti för att sidan är utan brister. Det är därför
        viktigt att man har möjlighet att även gå in på djupet och se vad de olika classerna får för enskilt resultat. Finns det någon bättringspotential? Eller man kanske helt enkelt får acceptera ett lite lägre resultat för att kunna uppnå det resulat man önskar.</p>

        <p>Veckans TIL är inte helt lätt att bestämma. Jag har lärt mig hur man avläser dessa två verktyg, de 6 C:en och ungefärliga nivåer dessa ska ligga på. Men samtidigt har jag, trots att jag inte lyckades genomföra fler tester, lärt mig hur man gör för att testa controllerklasser. Det var lite annorluna än
        enhetstester, så det var lärorikt. Synd bara att jag inte fick möjlighet att prova dem tack vare att phpunit inte kunde hitta KERNEL_CLASS, trots att jag satt den enligt instruktionerna. Men jag släpper det nu och taggar inför projektet istället.</p>

        <hr>
        <h2 id="kmom10">kmom10</h2>

        <p>Som slutprojekt på kursen valde jag att utveckla ett BlackJackspel. Jag tänkte eftersom det är begränsat med tid att jag valde detta för att kunna bygga vidare på mitt 21-spel jag gjort tidigare. Min första tanke var att det skulle gå väldigt fort. Men det visade sig kräva en hel del arbete ändå.</p>

        <p>Krav 1-3</p>
        <p>Dessa krav handlade om att bygga själva kortspelet samt att dokumentera och testa repot. Som design på sidan valde jag att frångå mitt tidigare grå-blå färgschema och istället köra på grönt och orange. Jag tyckte dessa färger passade bra i och med det handlar om ett kasino-spel och att dessa oftas spelas på
        grön filt. Vaöde även att ändra färgen på texten till vit då jag upplevde den lättare att läsa mot den gröna bakgrunden då. Själva kortspelet blev lite av en utmaning då det nu skulle gå att spela flera händer samtidigt, inte så svårt i sig, men när det dessutom skulle gå att satsa pengar per hand fick det
        mig att klura lite extra. Min första tanke var att ladda varje hand i taget och där välja hur mycket man skulle satsa. Jag tyckte dock inte det såg proffsigt ut så jag valde istället att lösa det med hjälp av javascript som känner av hur mycket man har i varje input på bettingsidan och att de sammanlagda värdena
        inte överstiger den tillgänglia summan. Utöver detta lånade jag ganska mycket kod från mitt 21-spel, men jag försökte göra den lite smidigare genom att lyfta ut if-satser till metoder vilket gjorde att koden i controller-sidan blev lite mer överskådlig.</p>

        <p>Gällande dokumentationen sjönk min Scrutinizer-poäng lite från 9.95 till 9.88. Det är egentligen inte så mycket med tanke på hur många nya filer jag lagt till och även lite tabeller i databasen. Min kodtäckning blev därför även den lägre och sjönk från 18% till 15%. Jag får fortfarande inte ordning på att testa
        controller-sidorna eller databasen så det är därför kodtäckningen är så pass låg. Ser man istället till klasserna så är min kodtäckning betydligt bättre där Helper och Utils ligger på 100% och Card ligger på 99.16%. Det är ett resultat jag får anse mig nöjd med. Även Phpmetrics ser helt okej ut. Vissa sidor är fortfarande
        lite höga i komplexibilitet och maintainability index, men jag vet helt ärligt inte hur jag ska lyckas få ner det utan att plocka bort funktioner ur kortspelet. Min README på github fick sig en rejäl uppdatering med insturktioner om hur man klonar och startar upp projektet.</p>

        <p>Krav 4</p>
        <p>I krav 4 skulle man skapa ett JSON API med 5 olika JSON routes. Även här fick jag fundera lite, jag ville ju inte bara ta saker rakt av från vad vi gjort i kursen tidigare så jag försökte tänka en extra gång på vad jag skulle visa. Det första jag kom på var att man skulle kunna söka på spelare i poänglistan.
        Det krävde att jag skapade en ny metod som använde sig av querybuildern. Jag valde även att göra så att man kan söka på början av namn, så om jag t ex söker på "da" får jag upp alla spelare vars namn börjar på "da". När man ändå kunde söka på spelare tänkte jag att det kunde vara trevligt att se alla spelare
        som fanns i databasen så det blev JSON-route nummer 2. Eftersom jag ändå jobbade med databasen var det även på sin plats att visa statistiken för banken, så helt plötsligt hade jag kommit på tre routes. När jag ändå var inne på statiskt kom jag snabbt på att det kunde vara trevligt att se procentsatsen för att
        nästa kort i leken skulle vara ett ess eller klätt kort. Nu hade jag bara en sista route kvar och då tyckte jag det kunde vara trevligt att visa de aktuella händernas kort. De två sista routsen krävde ju att det fanns ett spel i sessionen, men jag löste det med hjälp av en if-sats som kollar om det finns något
        resultat i sessionen, om inte så skapar vi en ny lek och i rout 5 även en hand att visa upp. Att jobba med JSON-routes är oftast inte särskilt avancerat om man redan skrivit koden för att visa upp datan i en twig så det var inte så svårt att implementera desssa.</p>

        <p>Krav 5</p>
        <p>Detta kraven innebar att jobba mot en databas med hjälp av Doctrines ORM. Det var nog det som jag upplevde som svårast med hela projektet. Bara att komma på vilka tabeller jag skulle ha i databasen gav mig huvudbry. Efter lite funderande kom jag fram till en form av spelarlista kunde vara trevligt. Tabellen
        skulle alltså hålla koll på spelarens namn, pengar och hur många rundor som spelats. Min första tanke var en form av topp-lista, men jag lyckades inte få till sorteringen i ORM så det fick helt enkelt bli att senaste spelaren läggs till i slutet på listan. I kravet stod det att man skulle ha minst två tabeller och
        jag hade otroligt svårt att komma på en tabell till som stod i relation till spelar-tabellen. Sen läste jag kravet igen och insåg att det kanske inte var helt tvunget att dessa skulle ha någon relation till varandra. Då kom jag fram till att det kunde vara trevligt att föra statistik över banken, hur många gånger den
        vunnit, förlorat eller fått samma som spelaren. Jag valde att använda SQLite, då jag inte hunnit sätta mig in i hur man avänder MariaDB ihop med Symfony. Att visa och uppdatera tabellerna sen var inte särskilt svårt, kmom05 lärde oss det ganska grundligt. Vad jag däremot hade väldiga problem med var att återskapa databasen.
        Om något skulle gå fel när databasen ligger på stundentservern vilket gör att det inte fungerar som tänkt hade det ju varit bra om läraren som rättar kan återställa databsen till ett tillstånd som jag väljer. Bankens tabell är t ex hårdkodad till id 1 (ska inte finnas fler i den tabellen), men om olyckan skulle vara framme
        och det id'et skulle raderas från databasen faller ju koden. Med hjälp av återställandet av databasen slipper jag oroa mig för det. Finns förmodligen både bättre och snyggare lösningar, men det var det bästa jag kom på för stunden. Att återkapa databasen var inget vi gick igenom, fick lite tips av Mikael och kollade i manualen.
        Problemet var att det stättet som visades i manualen med att anropa en system process för att köra linux kommandon inte fungerade för att köra filer. Som tur var fick jag hjälp av en kurskamrat, men jag la säkert större delen av en dag för att lösa detta.</p>

        <p>Krav 6</p>
        Här gällde det att berätta om några avancerade features man lagt in i sitt projekt. Jag var inte helt säker på om den texten skulle skrivas här direkt i rapporten eller i en separat sida under About-fliken. Jag valde i alla fall att lägga den som en som en länk på min About-sida, så här kommer bara en kort sammanfattning.
        De features jag anser vara lite mer än grundkraven är som ovan nämnt mitt bettingsystem. Där ett javascript håller koll på vad man bettar i de olika händerna. En annan sak jag valde att implemetera var att man kan se hur stor chans man har att nästa kort är klätt eller ess, som en lite enklare variant av korträkning. Utöver
        detta gjorde jag banken semi-intelligent i och med att den måste spela upp till 17 (vilket jag egentligen inte tycker är någon avancerad feature utan snarare ett grundkrav). Eftersom jag tycker statistik är trevligt så valde jag att använda databasen för att hålla statistik över hur mycket spelarna vunnit och hur bankens vinst, förlust
        och push-siffror ser ut. Överlag inga jätteavancerade saker, men med tanke på tidsramen är jag ändå nöjd med det jag presterade.</p>

        <hr></section>
        </main>
    </div>
{% endblock %}